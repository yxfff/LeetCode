1.求子集
LeetCode 78 Subsets
https://leetcode.com/problems/subsets/description/
已知一组数（无重复元素），求这组数可以组成的所有子集，结果中不可有无重复的子集

例：nums[]=[1,2,3]
结果：[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]

思路：
  利用回溯方法生成子集，即对于每个元素，都有放入和不放入集合中两个选择
  选择放入该元素，递归的进行后续元素的选择，完成放入该元素后续的试探。
  之后将其拿出，即再进行一次选择不放入的该元素，递归的进行后续元素的选择
  完成不放入该元素后续所有元素的试探。
代码：Subsets.java

思路2：（程序花费时间较长）
  利用位运算
  例：若一个集合有三个元素ABC，则三个元素有2^3=8种组成集合的方式，用0-7表示这些集合
  
  集合		整数		A	B	C
  {}		000=0		0	0	0
  {C}		001=1		0	0	1
  {B}		010=2		0	1	0
  {B,C}		011=3		0	1	1
  {A}		100=4		1	0	0
  {A,C}		101=5		1	0	1
  {A,B}		110=6		1	1	0
  {A,B,C}	111=7		1	1	1

  A元素为100=4，B元素为010=2，C元素为001=1
  构造某一集合，使用ABC对应的三个整数与该集合对应的整数做&运算，当为1时push到集合中

  集合		整数		A是否出现	B是否出现	C是否出现
  {}		000=0		100&000=0	010&000=0	001&000=0
  {C}		001=1		100&001=0	010&001=0	001&001=1
  {B}		010=2		100&010=0	010&010=1	001&010=0
  {B,C}		011=3		100&011=0	010&011=1	001&011=1
  {A}		100=4		100&100=1	010&100=0	001&100=0
  {A,C}		101=5		100&101=1	010&101=0	001&101=1
  {A,B}		110=6		100&110=1	010&110=1	001&110=0
  {A,B,C}	111=7		100&111=1	010&111=1	001&111=1	

代码为：SubsetsTwo.java

-------------------------------------------------------------------------------

2.求子集Ⅱ
LeetCode.90 Subsets Ⅱ
https://leetcode.com/problems/subsets-ii/discuss/
已知一组数（其中有重复元素），求这组数可以组成的所有子集，结果中无重复的子集
例如：nums[]=[2,1,2,2]
结果为：[[],[1],[1,2],[1,2,2],[1,2,2,2],[2],[2,2],[2,2,2]]
其中[2,1,2]和[1,2,2]是重复的集合

思路：
  先对nums进行排序，遍历时如果遇到nums[i-1]==nums[i],则直接跳到下一个
  while(pos<nums.length&&nums[pos-1]==nums[pos]){i++;}
代码：SubsetsDup.java

------------------------------------------------------------------------------

3.组合数之和
LeetCode 40. Combination Sum II
https://leetcode.com/problems/combination-sum-ii/description/

已知一组数（其中有重复元素），求这组数可以组成的所有子集中
子集中的各个元素和为整数target的子集。结果中无重复子集。

思路：
同2求子集，在此基础上进行调整
递归调用时，传入target，每次减去candidates[i]

代码为CombinationSum.java

-----------------------------------------------------------------------------
4.生成括号
LeetCode22. Generate Parentheses
https://leetcode.com/problems/generate-parentheses/description/

已知n组括号，生成n组括号所有合法组合可能
例如：n=3
结果为["((()))","(()())","(())()","()(())","()()()"]

思路：
采用递归方法，在所有组合中合法的为
1）左括号与有括号数量不可超过n
2）每放一个左括号，才能放一个右括号，即右括号不可以先于左括号放置

递归限制条件：
1）左括号与右括号数量最多放置n个
2）若左括号数量<=有括号数量，不可进行有括号的递归

代码为：GenerateParentheses.java

