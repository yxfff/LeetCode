1.LeetCode 455 Assign Cookies
https://leetcode.com/problems/assign-cookies/description/

已知一些孩子和一些糖果，每个孩子有一个需求因子g，每个糖果有大小s，当糖果的大小s>=某个孩子的
需求因子g时，代表该糖果可以满足该孩子，求使用这些糖果，最多能满足多少孩子？（一个孩子最多
只能被一个糖果满足）

贪心：
  目标：让更多孩子得到满足
  对g，s进行排序
  1.如果某个糖果不能满足某个孩子，则该糖果也一定不能满足需求因子更大的孩子
  2.某个孩子可以用更小的糖果满足，则没必要用更大的糖果满足，因为可以保留更大的糖果
满足需求因子更大的孩子。
  3.孩子的需求因子更小则更容易满足，所以优先从需求因子小的孩子尝试，得到正确的结果

思路：
  1.对需求因子数组g和糖果大小数组s进行从小到大排序
  2.按从小到大的顺序使用糖果尝试是否可以满足孩子，如果糖果只尝试一次，若尝试成功，则换
下一个孩子尝试，知道发现没有更多孩子或者更多糖果，循环结束

代码为：AssignCookies.java
---------------------------------------------------------------------------------
2.摇摆序列
LeetCode 376 Wiggle Subsequence
https://leetcode.com/problems/wiggle-subsequence/description/

一个整数序列，如果两个相邻元素的差恰好正负（负正）交替出现，则该序列被称为摇摆序列
，一个小于2个元素的序列直接为摇摆序列。
例如：
序列[1,7,4,9,2,5],相邻两个元素的差（6，-3,5，-7,3），该序列为摇摆序列
序列[1,4,7,2,5](3,3,-5,3)不是摇摆序列

给一个随机序列，求这个序列满足摇摆序列定义的最长子序列
例：
输入[1,7,4,9,2,5]结果为6

思路：
当序列有一段连续的递增或递减时，为形成摇摆子序列，只需要保留这段连续的递增或递减的
首尾元素，这样更可能使得尾部的后一个元素成为摇摆子序列的下一个元素。

建立一个状态转换机：
当状态发生转换时，最长摇摆子序列长度max_length++

BEGIN:
当nums[i-1]==nums[i]时，进入BEGIN状态
当nums[i-1]<nums[i]时，进入UP状态
当nums[i-1]>nums[i]时，进入DOWN状态

UP：
当nums[i-1]<=nums[i]时，进入UP状态
当nums[i-1]>nums[i]时，进入DOWN状态

DOWN：
当nums[i-1]>=nums[i]时，进入DOWN状态
当nums[i-1]<=nums[i]时，进入UP状态

代码为：MaxWiggle.java

------------------------------------------------------------------------
3.
LeetCode 402. Remove K Digits
https://leetcode.com/problems/remove-k-digits/description/
已知一个使用字符串表示的非负整数num，将num中的k个数字移除，求移除k个数字后
可以获得的最小的可能的新数字
（num不会以0开头，num长度小于10002）

eg：
输入：num="1322219"，k=3，
去掉三个数字后得到1219最小

思路：
 若去掉某一位数字，为了使得到的新数字最小，需要尽可能让得到的新数字优先
最高位最小，其次次高位最小，在其次第三位最小。

使用栈存储最终结果或删除工作，从高位向低位遍历num，日hip遍历的数字大于栈顶元素
则将该数字push入栈，如果小于栈顶元素则进行pop弹栈，直到栈为空或者不能再删除
数字（k==0）或栈顶小于当前元素为止。

当所有数字都扫描完，k仍然大于0时，继续弹栈删除数字

当数字中有0出现时，如果栈空，忽略0直接下一个数字，如果栈不为空，将0压入栈

代码：DeleteKDigits.java

