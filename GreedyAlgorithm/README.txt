1.LeetCode 455 Assign Cookies
https://leetcode.com/problems/assign-cookies/description/

已知一些孩子和一些糖果，每个孩子有一个需求因子g，每个糖果有大小s，当糖果的大小s>=某个孩子的
需求因子g时，代表该糖果可以满足该孩子，求使用这些糖果，最多能满足多少孩子？（一个孩子最多
只能被一个糖果满足）

贪心：
  目标：让更多孩子得到满足
  对g，s进行排序
  1.如果某个糖果不能满足某个孩子，则该糖果也一定不能满足需求因子更大的孩子
  2.某个孩子可以用更小的糖果满足，则没必要用更大的糖果满足，因为可以保留更大的糖果
满足需求因子更大的孩子。
  3.孩子的需求因子更小则更容易满足，所以优先从需求因子小的孩子尝试，得到正确的结果

思路：
  1.对需求因子数组g和糖果大小数组s进行从小到大排序
  2.按从小到大的顺序使用糖果尝试是否可以满足孩子，如果糖果只尝试一次，若尝试成功，则换
下一个孩子尝试，知道发现没有更多孩子或者更多糖果，循环结束

代码为：AssignCookies.java
---------------------------------------------------------------------------------
2.摇摆序列
LeetCode 376 Wiggle Subsequence
https://leetcode.com/problems/wiggle-subsequence/description/

一个整数序列，如果两个相邻元素的差恰好正负（负正）交替出现，则该序列被称为摇摆序列
，一个小于2个元素的序列直接为摇摆序列。
例如：
序列[1,7,4,9,2,5],相邻两个元素的差（6，-3,5，-7,3），该序列为摇摆序列
序列[1,4,7,2,5](3,3,-5,3)不是摇摆序列

给一个随机序列，求这个序列满足摇摆序列定义的最长子序列
例：
输入[1,7,4,9,2,5]结果为6

思路：
当序列有一段连续的递增或递减时，为形成摇摆子序列，只需要保留这段连续的递增或递减的
首尾元素，这样更可能使得尾部的后一个元素成为摇摆子序列的下一个元素。

建立一个状态转换机：
当状态发生转换时，最长摇摆子序列长度max_length++

BEGIN:
当nums[i-1]==nums[i]时，进入BEGIN状态
当nums[i-1]<nums[i]时，进入UP状态
当nums[i-1]>nums[i]时，进入DOWN状态

UP：
当nums[i-1]<=nums[i]时，进入UP状态
当nums[i-1]>nums[i]时，进入DOWN状态

DOWN：
当nums[i-1]>=nums[i]时，进入DOWN状态
当nums[i-1]<=nums[i]时，进入UP状态

代码为：MaxWiggle.java

------------------------------------------------------------------------
3.
LeetCode 402. Remove K Digits
https://leetcode.com/problems/remove-k-digits/description/
已知一个使用字符串表示的非负整数num，将num中的k个数字移除，求移除k个数字后
可以获得的最小的可能的新数字
（num不会以0开头，num长度小于10002）

eg：
输入：num="1322219"，k=3，
去掉三个数字后得到1219最小

思路：
 若去掉某一位数字，为了使得到的新数字最小，需要尽可能让得到的新数字优先
最高位最小，其次次高位最小，在其次第三位最小。

使用栈存储最终结果或删除工作，从高位向低位遍历num，日hip遍历的数字大于栈顶元素
则将该数字push入栈，如果小于栈顶元素则进行pop弹栈，直到栈为空或者不能再删除
数字（k==0）或栈顶小于当前元素为止。

当所有数字都扫描完，k仍然大于0时，继续弹栈删除数字

当数字中有0出现时，如果栈空，忽略0直接下一个数字，如果栈不为空，将0压入栈

代码：DeleteKDigits.java

------------------------------------------------------------------------
4.跳跃游戏
LeetCode55 Jump Game
https://leetcode.com/problems/jump-game/description/

一个数组存储了非负整型数据，数组的第i个元素nums[i]，代表了可以从数组第i个位置最多向前
跳跃nums[i]步，已知数组各元素的情况下，求是否可以从数组的第0个位置跳跃到数组的最后一个
元素的位置？
例如：
nums=[2,3,1,1,4]。可以从nums[0]=2跳跃到nums[4]=4
nums=[3,2,1,0,4],不可以从nums[0]=3跳跃到nums[4]=4

思路：
  如果从第0位置最远可以跳至第i个位置，则从第0位置也一定可以跳至
  第1个位置，第2个位置...第i-1个位置
  
  所以从第0个位置应该跳至第1,2...i-1，i位置中，又可向前跳至更远位置
  即index[1],index[2],...,index[i-1],index[i]最大的那个位置

  定义一个数组index[]用来存储从第i个位置最远可以跳到的位置
  index[i]=nums[i]+i;
  eg:
    位置：               [0,1,2,3,4]
    最远跳跃nums：       [2,3,1,1,4]
    最远达到的位置index: [2,4,3,4,8]

  用变量jump扫描index数组，直到jump达到index数组尾部或者jump超过max_index，扫描过程中更新max_index
  当最后jump与index.size（）相等时，返回true
代码：JumpGame.java

--------------------------------------------------------------------------
5.跳跃游戏2
LeetCode 45 Jump Game II
https://leetcode.com/problems/jump-game-ii/description/
一个数组存储了非负整型数据，数组中的第i个元素nums[i],代表了可以从数组的第i个
位置最多向前跳跃nums[i]步，已知数组各元素的情况下，确认可以从第0位置跳跃到数组
最后一个位置，求最少需要跳跃几次？

示例：
nums =[2,3,1,1,4]
从0位置跳到第1个位置，从第一个位置跳至最后一个位置。

思路：
  在无法到达更远的地方时，在这之前应该跳至一个可以到达更远位置的位置

  1.设置current_max_index为当前可达到的最远位置
  eg：[2,3,1,1,4],遍历到第0个位置时，current_max_index为第2个位置1
  2.设置pre_max_max_index为在遍历各个位置过程中，各个位置可到达的最远位置
  eg: [2,3,1,1,4],遍历到第0个位置时，可以跳到第1,2个位置，跳至第一个位置时，
      可以跳到更远位置为第4个位置即最后一个位置
  3.设置jump_min为最少跳跃的次数
  4.利用i遍历nums数组，若i超过current_max_index,jump_min加1
  5.遍历过程中，若nums[i]+i更大，则更新pre_max_max_index=nums[i]+i

代码为：JumpGameTwo.java

----------------------------------------------------------------------------
6.射击气球
LeetCode 452 Minimum Number of Arrows to Burst Balloons
https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/

已知在一个平面上有一定数量的气球，平面可以看作一个坐标系，在平面的x轴不同位置安排弓箭手
向y轴方向射箭，弓箭可以向y轴走无穷远，给定气球的宽度xstartx<=x<=xend,问至少需要多少弓箭手，
将全部气球打爆？


思路：
 1.对各个气球进行排序，按照气球的左端点从小到大排序
 2.遍历气球数组，同时维护一个射击区间，在满足可以将当前气球射穿的情况下，尽可能击穿
更多气球，每击穿一个新的气球，更新一次射击区间（保证射击区间可以将新气球也击穿）
 3.如果新的气球没办法被击穿了，则需要增加一名弓箭手

即：从头遍历找最大的重叠区域，当无法再增加重叠区域时，增加一个弓箭手，重新计算重叠区域。
代码为：MinimumOfArrows.java
 